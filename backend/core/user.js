// Generated by CoffeeScript 1.7.1
(function() {
  var User, Utils, async, hash, jwt, serverConfig, userRoles;

  jwt = require('jwt-simple');

  async = require('async');

  hash = require('./pass').hash;

  serverConfig = require('../config/init').serverConfig;

  Utils = require('./utils').Utils;

  userRoles = require('./routing-config').userRoles;

  User = (function() {
    function User() {}

    User.dbProvider = null;

    User.cacheTokens = [];

    User.getUser = function(siteId, name, callback) {
      var findConditions;
      findConditions = null;
      if (siteId === 0 || siteId === '0') {
        findConditions = {
          username: name
        };
      } else {
        findConditions = {
          site: siteId,
          username: name
        };
      }
      Utils.logInfo(findConditions);
      User.dbProvider.Users.findOne(findConditions, function(err, user) {
        callback(err, user);
      });
    };

    User.getFbUser = function(name, callback) {
      User.dbProvider.FbUsers.findOne({
        username: name
      }, function(err, user) {
        callback(err, user);
      });
    };

    User.getFbUserById = function(id, callback) {
      User.dbProvider.FbUsers.findOne({
        fbId: id
      }, function(err, user) {
        callback(err, user);
      });
    };

    User.createSite = function(site, callback) {
      User.dbProvider.Site.create(site, function(error, doc) {
        callback(error, doc);
      });
    };

    User.updateSite = function(siteId, value, callback) {
      User.dbProvider.Site.findByIdAndUpdate(siteId, value, function(error, doc) {
        return callback(error, doc);
      });
    };

    User.saveUser = function(user, callback) {
      User.dbProvider.Users.create(user, function(error, doc) {
        callback(error, doc);
      });
    };

    User.updateUser = function(user, callback) {
      var id;
      id = user._id;
      delete user._id;
      User.dbProvider.Users.findByIdAndUpdate(id, user, function(error, doc) {
        callback(error, doc);
      });
    };

    User.authenticate = function(siteId, userName, passWord, callback) {
      var user;
      Utils.logInfo('Authenticating starting...');
      Utils.logInfo('siteId: ', siteId);
      Utils.logInfo('username: ', userName);
      Utils.logInfo('password: ', passWord);
      if (siteId === '0' && userName === 'anon') {
        user = {};
        user.site = siteId;
        user.id = '0';
        user.name = userName;
        user.fullname = 'Anonymous User';
        user.role = 'anon';
        callback(null, user);
      } else {
        async.waterfall([
          function(cb) {
            User.getUser(siteId, userName, function(error, user) {
              cb(error, user);
            });
          }, function(user, cb) {
            var errMsg;
            if (user) {
              hash(passWord, user.salt, function(err, hash) {
                cb(err, user, hash);
              });
            } else {
              errMsg = 'Invalid login';
              cb(errMsg, null);
              Utils.logInfo('Authenticating', 'error', errMsg);
            }
          }, function(user, hash, cb) {
            var errMsg;
            if (hash === user.hash) {
              cb(null, user);
            } else {
              errMsg = 'Invalid login';
              cb(errMsg, null);
            }
          }
        ], function(error, result) {
          callback(error, result);
        });
      }
    };

    User.authenticateSuccess = function(req, res) {
      var client_ip, expired_date, token, user;
      expired_date = new Date();
      expired_date.setMinutes(expired_date.getMinutes() + 6 * 60);
      client_ip = Utils.getClientIp(req);
      user = {};
      user.site = req.user.site;
      user.id = req.user.id;
      user.name = req.user.username;
      user.fullname = req.user.fullname;
      user.role = userRoles[req.user.role];
      user.expired = expired_date;
      user.ip = client_ip;
      token = jwt.encode(user, serverConfig._tokenScrete);
      User.cacheTokens.push(token);
      res.send({
        user: user,
        token: token
      }, 200);
    };

    User.logout = function(req, res) {
      var ip, token;
      token = req.headers['authorization'] || req.query.token;
      ip = Utils.getClientIp(req);
      User.verifyToken(token, ip, function(error, user) {
        var foundToken, index, item, _i, _len, _ref;
        if (user) {
          index = 0;
          foundToken = null;
          _ref = User.cacheTokens;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            item = _ref[_i];
            if (item === token) {
              foundToken = index;
            }
            index++;
          }
          if (foundToken) {
            User.cacheTokens.splice(foundToken, 1);
          }
          res.send({
            success: true
          });
        } else {
          res.send({
            success: false,
            message: error
          });
        }
      });
    };

    User.register = function(req, res) {
      var fullName, password, userName;
      userName = req.body.username;
      fullName = req.body.fullname;
      password = req.body.password;
      async.waterfall([
        function(cb) {
          hash(password, function(err, salt, hash) {
            cb(err, salt, hash);
          });
        }, function(salt, hash, cb) {
          var user;
          user = {
            username: userName,
            fullname: fullName,
            salt: salt,
            hash: hash
          };
          Utils.logInfo('user: ', user);
          User.saveUser(user, function(error, result) {
            cb(error, result);
          });
        }
      ], function(error, result) {
        var msg;
        if (error) {
          msg = error;
        } else {
          msg = 'Registration Success';
        }
        res.send({
          message: msg
        }, 200);
      });
    };

    User.registerSite = function(req, res) {
      var adminData, siteData;
      siteData = {};
      siteData.name = req.body.siteName || 'DefaultNewSite';
      siteData.description = req.body.siteDescription;
      siteData.logoUrl = req.body.siteLogoUrl;
      siteData.address = req.body.siteAddress;
      siteData.telephone = req.body.siteTelephone;
      siteData.totalTable = req.body.siteTotalTable;
      adminData = {};
      adminData.username = req.body.adminName || siteData.name + 'Admin';
      adminData.fullname = req.body.adminFullName || 'Site Admin';
      adminData.password = req.body.adminPassword || '123456';
      adminData.role = 'admin';
      async.waterfall([
        function(cb) {
          Utils.logInfo('newSite: ', siteData);
          User.createSite(siteData, function(error, result) {
            cb(error, result);
          });
        }, function(newSite, cb) {
          hash(adminData.password, function(err, salt, hash) {
            cb(err, newSite, salt, hash);
          });
        }, function(newSite, salt, hash, cb) {
          adminData.site = newSite.id;
          adminData.salt = salt;
          adminData.hash = hash;
          User.saveUser(adminData, function(error, siteAdmin) {
            cb(error, newSite, siteAdmin);
          });
        }, function(newSite, siteAdmin, cb) {
          var adminId, siteId;
          siteId = newSite.id;
          adminId = siteAdmin.id;
          User.updateSite(siteId, {
            admin: adminId
          }, function(error, updatedSite) {
            cb(error, updatedSite, siteAdmin);
          });
        }
      ], function(error, newSite, siteAdmin) {
        var msg, success;
        success = false;
        if (error) {
          success = false;
          msg = error;
        } else {
          success = true;
          msg = 'Site registration was successed';
        }
        res.send({
          success: success,
          message: msg,
          newSite: newSite,
          siteAdmin: siteAdmin
        }, 200);
      });
    };

    User.verifyToken = function(token, ip, cb) {
      var e, errMsg, foundToken, item, user, _i, _len, _ref;
      Utils.logInfo('verifyToken...');
      Utils.logInfo("request_ip: ", ip);
      errMsg = '';
      user = null;
      if (!token) {
        errMsg = 'Token is null';
      } else {
        try {
          foundToken = false;
          _ref = this.cacheTokens;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            item = _ref[_i];
            if (item === token) {
              foundToken = true;
            }
          }
          if (!foundToken) {
            errMsg = 'Token is not found';
          } else {
            user = jwt.decode(token, serverConfig._tokenScrete);
            if (user.ip === ip) {
              if (new Date(user.expired) < new Date()) {
                errMsg = 'Token was expired';
              }
            } else {
              errMsg = 'Token has invalid ip address: ' + ip;
            }
          }
        } catch (_error) {
          e = _error;
          errMsg = 'Token decode eror: ' + e.toString();
        }
      }
      if (errMsg === '') {
        cb(null, user);
        Utils.logInfo('verifyToken OK, user:', user);
      } else {
        cb(errMsg, false);
        Utils.logError(errMsg);
      }
    };

    User.validateToken = function(req, res) {
      var ip, token;
      token = req.headers['authorization'] || req.query.token;
      ip = Utils.getClientIp(req);
      User.verifyToken(token, ip, function(error, user) {
        if (user) {
          res.send({
            success: true,
            user: user
          });
        } else {
          res.send({
            success: false,
            message: error
          });
        }
      });
    };

    User.restrict = function(req, res, next) {
      var clientIp, token;
      token = req.headers['authorization'] || req.query.token;
      clientIp = Utils.getClientIp(req);
      User.verifyToken(token, clientIp, function(error, user) {
        if (user) {
          req.loginUser = user;
          next();
        } else {
          res.send({
            message: 'Unauthenticated',
            error: error || ''
          }, 401);
        }
      });
    };

    User.deserializeUser = function(id, done) {
      async.waterfall([
        function(cb) {
          return User.getFbUser(id, function(err, user) {
            return cb(err, user);
          });
        }, function(user, cb) {
          if (user) {
            return cb(null, user);
          } else {
            return User.getUser(id, function(err, user) {
              return cb(err, user);
            });
          }
        }
      ], function(error, result) {
        return done(error, result);
      });
    };

    User.authenticatedOrNot = function(req, res, next) {
      if (req.isAuthenticated()) {
        return next();
      } else {
        return res.redirect("/login");
      }
    };

    User.userExist = function(req, res, next) {
      return this.dbProvider.Users.count({
        username: req.body.username
      }, function(err, count) {
        if (count === 0) {
          return next();
        } else {
          return res.redirect("/singup");
        }
      });
    };

    return User;

  })();

  exports.User = User;

}).call(this);

//# sourceMappingURL=user.map
