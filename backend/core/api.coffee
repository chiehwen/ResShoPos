async = require 'async'
_ = require 'underscore'

{ Utils } = require './utils'


###
# CoffeeDoc example documentation #

This is a module-level docstring, and will be displayed at the top of the module documentation.
Documentation generated by [CoffeeDoc](http://github.com/omarkhan/coffeedoc)
###

class BaseCrud
  @createError: (method) ->
    error = new Error "Unimplemented #{method}"
    return error
    
  @read: (BaseModelClazz, aFilter = [], sQuery = '', aSort = [], iOffset = 0, iLimit = 15, callback) =>
    callback @createError('read'), null, null, null
    return

  @readOne: (BaseModelClazz, id, callback) =>
    callback @createError('readOne'), null
    return
    
  @create: (BaseModelClazz, value, callback) =>
    callback @createError('create'), null
    return

  @update: (BaseModelClazz, id, value, callback) =>
    callback @createError('update'), null
    return

  @delete: (BaseModelClazz, id, callback) =>
    callback @createError('delete'), null
    return
    
exports.BaseCrud = BaseCrud

###
This docstring documents MongooseCrud. It can include *Markdown* syntax,
which will be converted to html.
###

class MongooseCrud extends BaseCrud
  @read: (MongooseModelClazz, aFilter = [], sQuery = '', aSort = [], aGroup = [], iOffset = 0, iLimit = 15, callback) =>
    findOptions = {}
    oWhere = {}
    
    findOptions.skip = parseInt iOffset
    findOptions.limit = parseInt iLimit
    
    ###
    Get order list from aSort
    each element is a object {field, dir}
    ###
    findOptions.order = aSort.reduce (l, r) ->
      s = r.field + ' ' + r.dir.toUpperCase()
      if l is ''
        l = s
      else
        l += ',' + s
      return l
    , ''
    
    operMap =
      eq: '='
      lt: '<'
      gt: '>'
      gte: '>='
      lte: '<='
      ne: '!='
      bt: 'BETWEEN'
      nbt: 'NOT BETWEEN'
      like: 'LIKE'
      
    ###
    Get where list from aFilter
    each element is a object {field, cmp, value}
    ###
    reduceWhere = aFilter.reduce (l, r)->
      sHolder = l.holder
      aValues = l.values
      
      s = r.field + ' ' + operMap[r.cmp] + ' ? '
      
      aValues.push r.value
      
      if sHolder is ''
        sHolder = s
      else
        sHolder += ' AND ' + s
        
      ret = 
        holder: sHolder
        values: aValues
      return ret
    , {holder: '', values: []}
    
    
    if reduceWhere.holder isnt '' and reduceWhere.values.length >0
      cWhere1 = [reduceWhere.holder]
      cWhere1.push value for value in reduceWhere.values
      
      cWhere2 = [reduceWhere.holder]
      cWhere2.push value for value in reduceWhere.values
      
      findOptions['where'] = cWhere1
      oWhere = 'where' : cWhere2
      
    findOptions = {}
    oWhere = {}
    
    async.waterfall [
      (cb) =>
        MongooseModelClazz.count oWhere, (err, return_count) ->
          cb err, return_count
          return
        return
      (return_count, cb) =>
        MongooseModelClazz.find findOptions, (error,docs) ->
          cb error, docs, return_count
          return
        return
    ], (error, docs, return_count) ->
      sumDoc = {}
      callback error, docs, return_count, sumDoc
      return
    return
  
  @readOne: (MongooseModelClazz, id, callback) =>
    MongooseModelClazz.findById id, (error,doc) ->
      callback error, doc
    return
    
  @create: (MongooseModelClazz, value, callback) =>
    MongooseModelClazz.create value, (error, doc) =>
      callback error, doc
    return

  @update: (MongooseModelClazz, id, value, callback) =>
    MongooseModelClazz.findByIdAndUpdate id, value, (error,doc) ->
      callback error, doc
    return


  @delete: (MongooseModelClazz, id, callback) =>
    async.waterfall [
      (cb) =>
        MongooseModelClazz.findById id, (error,doc) ->
          cb error, doc
          return
        return
      (doc, cb) =>
        MongooseModelClazz.remove {_id: id}, (error) ->
          cb error, doc
          return
        return
    ], (error, doc) ->
      callback error, doc
      
    return
      


class BaseClientApi
  createError: (method) ->
    error = new Error "Unimplemented #{method}"
    return error
    
  setReq: (req) =>
    @req = req
    console.log JSON.stringify(req.query, null, '\t')
    return
    
  getFilter: =>
    throw @createError('getFilter')
    return
    
  getQuery: =>
    throw @createError('getQuery')
    return
  
  getSort: =>
    throw @createError('getSort')
    return
  
  getGroup: =>
    throw @createError('getGroup')
    return
    
  getOffset: =>
    throw @createError('getOffset')
    return
  
  getLimit: =>
    throw @createError('getLimit')
    return
    
  getTableName: =>
    return Utils.firstUpperCase(@req.params.collection)
    
  getRecordId: =>
    return @req.params.id
    
  getPostValue: =>
    return @req.body
    
  checkReqParamsOk: =>
    result = ''

    databaseName = @req.params.database
    collectionName = @req.params.collection

    if not databaseName?
      result = 'Database name Undefined'

    if not collectionName?
      result  = 'Collection name Undefined'

    return result

  _logParamsQuery: (msg, value) ->
      console.log msg
      console.log(if _.isString(value) then value else JSON.stringify(value, null, '\t'))


exports.BaseClientApi = BaseClientApi  




class ClientApi
  @setReq: (req) =>
    @req = req
    
    console.log JSON.stringify(req.query, null, '\t')
    
    return
    
  @getFilter: =>
    filter = @req.query.filter
    
    elements = []
    if filter?
      #@_logParamsQuery 'Filter defined', filter
      
      if _.isString filter
        els = @getConditionFromString filter
        elements.push el for el in els
      else if _.isArray filter
        elements = @getConditionFromArray filter
    
    return elements
    
  @getQuery: =>
    query = @req.query.query
    return query      
  
  @getSort: =>
    sort = @req.query.sort
    mapSort = []
    
    if sort?
      #@_logParamsQuery 'Sort defined: ', sort
      
      if _.isString sort
        sortArr = JSON.parse sort
        
        if _.isArray sortArr
          mapSort = sortArr.map (item) -> {field: item.property, dir: item.direction}
        
    return mapSort
  
  
  @getGroup: =>
    group = @req.query.group
    mapGroup = []
    
    if group?
      #@_logParamsQuery 'Group defined', group
    
      if _.isString group
        groupArr = JSON.parse group
        
        if _.isArray groupArr
          mapGroup = groupArr.map (item) -> {field: item.property, dir: item.direction}
          
    return mapGroup
    
  @getOffset: =>
    return @req.query.start
  
  @getLimit: =>
    return @req.query.limit

  @getTableName: =>
    return Utils.firstUpperCase(@req.params.collection)
    
  @getRecordId: =>
    return @req.params.id
    
  @getPostValue: =>
    return @req.body
    
  @checkReqParamsOk: =>
    result = ''

    databaseName = @req.params.database
    collectionName = @req.params.collection

    if not databaseName?
      result = 'Database name Undefined'

    if not collectionName?
      result  = 'Collection name Undefined'

    return result

  @_logParamsQuery: (msg, value) ->
      console.log msg
      console.log(if _.isString(value) then value else JSON.stringify(value, null, '\t'))
    
  @getConditionFromString: (filter) =>
    elements = []
    items = JSON.parse filter
    
    if _.isArray items
      for item in items
        element = {field: item.property, value: item.value, type: '', cmp: 'eq'}
        elements.push element
      
    return elements
    
  @getConditionFromArray: (filter) =>
    elements = []
    for item in filter
      if _.isString item
        els = @getConditionFromString(item)
        elements.push el for el in els
      else if _.isObject item
        element = {field: item.field, value: item.data.value, type: item.data.type, cmp: item.data.comparison}
        elements.push element
        
    return elements


exports.ClientApi = ClientApi  
  
  
  
class AppApiNew
  @dbProvider: null

  @query: (req, res) =>
    
    actionName = 'read'
    actionDesc = 'Querying'
    
    @tryAction req, res, actionName, actionDesc, ->
      aFilter = ClientApi.getFilter()
      sQuery = ClientApi.getQuery()
      aSort = ClientApi.getSort()
      aGroup = ClientApi.getGroup()
      iOffset = ClientApi.getOffset()
      iLimit = ClientApi.getLimit()
      return [aFilter, sQuery, aSort, aGroup, iOffset, iLimit]
    
    return


  @findOne: (req, res) =>
    actionName = 'readOne'
    actionDesc = 'Read One'
	
    @tryAction req, res, actionName, actionDesc, ->
      id = ClientApi.getRecordId()
      return [id]
      
    return

    
  @insert: (req, res) =>
    actionName = 'create'
    actionDesc = 'Create One'
    
    @tryAction req, res, actionName, actionDesc, ->
      value = ClientApi.getPostValue()
      delete value.id if value? and value.id?
      return [value]
    
    return

    
  @updateOne: (req, res) =>
    actionName = 'update'
    actionDesc = 'Update One'
    
    @tryAction req, res, actionName, actionDesc, ->
      id = ClientApi.getRecordId()
      value = ClientApi.getPostValue()
      delete value.id if value? and value.id?
      return [id, value]
		
    return

    
  @remove: (req, res) =>
    actionName = 'delete'
    actionDesc = 'Delete One'
    
    @tryAction req, res, actionName, actionDesc, ->
      id = ClientApi.getRecordId()
      return [id]
		
    return
    
    
  @getTree: (req, res) =>
    return
    
    
  @tryAction: (req, res, actionName, actionDesc, fn) =>
    action = @createAction req, res, actionName, actionDesc
    if action and fn
      args = fn()
      @actionProcess action, args
      
    return
    
    
  @createAction: (req, res, sName, sDesc) ->
    ret = false
    
    #@clientApi = ClientApi
    #@clientApi.setReq req
    
    ClientApi.setReq req
    
    msgCheck = ClientApi.checkReqParamsOk()
    if msgCheck isnt ''
      action = 
        req: req
        res: res
        actionName: sName
        actionDescription: sDesc
        tableName: ''
        msgError: "ERROR: #{sDesc} \n"
        msgSuccess: "SUCCESS: #{sDesc} \n"
        
      @actionBegin action    
      @actionEnd action, msgCheck, null, null
    else  
      sTable = ClientApi.getTableName()
      ret = 
        req: req
        res: res
        actionName: sName
        actionDescription: sDesc
        tableName: sTable
        msgError: "ERROR: #{sDesc} #{sTable} \n"
        msgSuccess: "SUCCESS: #{sDesc} #{sTable} \n"
        
    return ret
    
  @actionProcess: (action, args = []) =>
    @actionBegin action
    
    ModelClazz = @dbProvider[action.tableName]
    
    if not ModelClazz
      @actionEnd action, "Model Class #{action.tableName} does not exist", null, null
    else
      fn = MongooseCrud[action.actionName]
      
      callback = (err, docs, total_count, sum_doc) =>
        @actionEnd action, err, docs, (total_count or 1), sum_doc or null
        
      args.unshift ModelClazz
      args.push callback
      
      fn.apply @, args
  
  @actionBegin: (action)->
    console.log "BEGIN: #{action.actionDescription} #{action.tableName}"
  
  @actionEnd: (action, err, docs, total, sum_doc) =>
    if err
      console.log action.msgError
      console.log err
    else
      console.log action.msgSuccess
      
    ret =
      data: (docs or {})
      success: (not err)
      total: total
      message: err
      groupSummaryData: [sum_doc]
      
    #console.log JSON.stringify(ret, null, '\t')
    
    action.res.contentType 'application/json'
    action.res.send ret
    
    return
    
exports.AppApiNew = AppApiNew
